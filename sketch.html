<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

<head>
    <title>3D Project Management</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,700italic,400italic,300,300italic" rel="stylesheet" type="text/css">
    <link rel=stylesheet href="css/jquery-ui.min.css" />
    <link rel=stylesheet href="css/custom.css" />
    <link rel=stylesheet href="css/info.css" />
    <script src="js/jquery-3.1.1.js"></script>
    <script src="js/jquery-ui.min.js"></script>
    <script src="js/info.js"></script>
    <script src="js/three.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/orbitcontrols.js"></script>
    <script src="js/threex.dynamictexture.js"></script>
    <script src="js/cube.js"></script>
    <script src="js/project-wbs.js"></script>
</head>

<body>
    <div id="infoButton"></div>
    <div id="infoBox" title="3D Project Management - Project Information">
        This Three.js project is the final work for the Master's degree Software Engineering Laboratory discipline at UFRJ - Federal
        University of Rio Janeiro | Date: 2016-12-19<br> Source code available @: <a href="https://github.com/leniel/3DPM"
            target="_blank">https://github.com/leniel/3DPM</a>
    </div>
    <div id="title">
        <h1>3D Project Management - Demo</h1>
        <i>by Leniel Macaferi & DÃ¡ve Liao</i>
        <p>Play with the scene using your mouse or keyboard</p>
    </div>
    <div id="container"></div>
</body>
<script type="text/javascript">
    var container, stats;
    var camera, scene, renderer;
    var rayCaster;
    var mouse;

    var width = window.innerWidth;
    var height = window.innerHeight;

    renderer = new THREE.WebGLRenderer({
        antialias: true
    });
    renderer.setClearColor(0xf0f0f0);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);

    init();
    animate();

    controls = new THREE.OrbitControls(camera);
    controls.enableZoom = true;
    controls.zoomSpeed = 0.5;
    controls.enableRotate = true;
    controls.rotateSpeed = 0.25;
    controls.enablePan = true;
    controls.autoRotate = false;

    function init() {
        container = $("#container");

        container.append(renderer.domElement);

        rayCaster = new THREE.Raycaster();
        mouse = new THREE.Vector3();

        scene = new THREE.Scene();

        camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 0.1, 1000);
        camera.position.set(0, 0, 500);
        camera.lookAt(scene.position);
        scene.add(camera);

        var light = new THREE.AmbientLight(0xffffff, 0.1);
        camera.add(light);
        
        createProjectWorkBreakDownStructure();

        

        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('touchstart', onDocumentTouchStart, false);

        window.addEventListener('resize', onWindowResize, false);

    }

    function animate() {
        requestAnimationFrame(animate);

        render();

        //stats.update();
    }

    function render() {
        renderer.render(scene, camera);
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function onDocumentTouchStart(event) {

        event.preventDefault();

        event.clientX = event.touches[0].clientX;
        event.clientY = event.touches[0].clientY;

        onDocumentMouseDown(event);
    }

    function onDocumentMouseDown(e) {

        //e.preventDefault();

        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        rayCaster.setFromCamera(mouse, camera);

        var intersects = rayCaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {

            console.log(intersects[0].object.name);

            var cubeFaceIndex = intersects[0].face.materialIndex; // Getting which face was clicked...

            changeDynamicTexture(intersects[0].object, cubeFaceIndex, {
                color: 'orange',
                text: '1',
                textColor: 'yellow'
            });
        }
    }

</script>

</html>